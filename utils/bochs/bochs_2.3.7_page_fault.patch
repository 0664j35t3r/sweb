diff -r a9d46eea0609 bochs.h
--- bochs.h	Fri Jun 13 16:53:20 2008 +0200
+++ bochs.h	Fri Jun 13 17:02:35 2008 +0200
@@ -129,6 +129,10 @@ Bit32u crc32(const Bit8u *buf, int len);
 Bit32u crc32(const Bit8u *buf, int len);
 // for param-tree testing only
 void print_tree(bx_param_c *node, int level = 0);
+
+//BEGIN EDIT os page fault
+void bochs_os_page_fault(Bit8u vector);
+//END EDIT os page fault
 
 //
 // some macros to interface the CPU and memory to external environment
diff -r a9d46eea0609 cpu/exception.cc
--- cpu/exception.cc	Fri Jun 13 16:53:20 2008 +0200
+++ cpu/exception.cc	Fri Jun 13 17:02:35 2008 +0200
@@ -345,7 +345,6 @@ void BX_CPU_C::protected_mode_int(Bit8u 
     BX_ERROR(("interrupt(): gate not present"));
     exception(BX_NP_EXCEPTION, vector*8 + 2, 0);
   }
-
   switch (gate_descriptor.type) {
   case BX_TASK_GATE:
     // examine selector to TSS, given in task gate descriptor
@@ -791,7 +790,6 @@ void BX_CPU_C::interrupt(Bit8u vector, b
 #endif
   bx_dbg_interrupt(BX_CPU_ID, vector, error_code);
 #endif
-
   BX_DEBUG(("interrupt(): vector = %u, INT = %u, EXT = %u",
       (unsigned) vector, (unsigned) is_INT, (unsigned) BX_CPU_THIS_PTR EXT));
 
@@ -814,7 +812,6 @@ void BX_CPU_C::interrupt(Bit8u vector, b
     return;
   }
 #endif
-
   if(real_mode()) {
     real_mode_int(vector, is_INT, is_error_code, error_code);
   }
@@ -1039,6 +1036,12 @@ void BX_CPU_C::exception(unsigned vector
 
   BX_CPU_THIS_PTR errorno++;
 
+//BEGIN EDIT os page fault
+#if BX_GDBSTUB
+  bochs_os_page_fault(vector);
+#endif
+//END EDIT os page fault
+
   if (real_mode()) {
     // not INT, no error code pushed
     BX_CPU_THIS_PTR interrupt(vector, 0, 0, 0);
diff -r a9d46eea0609 gdbstub.cc
--- gdbstub.cc	Fri Jun 13 16:53:20 2008 +0200
+++ gdbstub.cc	Fri Jun 13 17:02:35 2008 +0200
@@ -47,6 +47,9 @@ static int last_stop_reason = GDBSTUB_ST
 #define GDBSTUB_EXECUTION_BREAKPOINT    (0xac1)
 #define GDBSTUB_TRACE                   (0xac2)
 #define GDBSTUB_USER_BREAK              (0xac3)
+//BEGIN EDIT os page fault
+#define GDBSTUB_OS_PAGE_FAULT		(0xac4)
+//END EDIT os page fault
 
 static bx_list_c *gdbstub_list;
 static int listen_socket_fd;
@@ -180,6 +183,18 @@ static void get_command(char* buffer)
   } while (checksum != xmitcsum);
 }
 
+
+//BEGIN EDIT os page fault
+void bochs_os_page_fault(Bit8u vector)
+{
+  if(vector == 0x0E)
+  {
+    last_stop_reason = GDBSTUB_OS_PAGE_FAULT;  
+  }
+}
+//END EDIT
+
+
 void hex2mem(char* buf, unsigned char* mem, int count)
 {
   int i;
@@ -266,6 +281,8 @@ int bx_gdbstub_check(unsigned int eip)
   unsigned char ch;
   long arg;
   int r;
+  
+  
 #if defined(__CYGWIN__) || defined(__MINGW32__)
   fd_set fds;
   struct timeval tv = {0, 0};
@@ -319,6 +336,12 @@ int bx_gdbstub_check(unsigned int eip)
     last_stop_reason = GDBSTUB_TRACE;
     return GDBSTUB_TRACE;
   }
+  
+  if(last_stop_reason == GDBSTUB_OS_PAGE_FAULT)
+  {
+  	return last_stop_reason;
+  }
+  
   last_stop_reason = GDBSTUB_STOP_NO_REASON;
   return GDBSTUB_STOP_NO_REASON;
 }
@@ -488,6 +511,13 @@ static void debug_loop(void)
         {
           write_signal(&buf[1], SIGTRAP);
         }
+        //BEGIN EDIT os page fault
+        else if(last_stop_reason == GDBSTUB_OS_PAGE_FAULT)
+        {
+          write_signal(&buf[1], SIGSEGV);
+          last_stop_reason = GDBSTUB_STOP_NO_REASON;
+        }
+        //END EDIT os page fault
         else
         {
           write_signal(&buf[1], 0);
@@ -512,6 +542,13 @@ static void debug_loop(void)
         {
           write_signal(&buf[1], SIGTRAP);
         }
+        //BEGIN EDIT os page fault
+        else if(last_stop_reason == GDBSTUB_OS_PAGE_FAULT)
+        {
+          write_signal(&buf[1], SIGSEGV);
+          last_stop_reason = GDBSTUB_STOP_NO_REASON;
+        }
+        //END EDIT os page fault
         else
         {
           write_signal(&buf[1], SIGTRAP);
