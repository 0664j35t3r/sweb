# bochsrc: configuration for the bochs emulator

# You may now use double quotes around pathnames, in case
# your pathname includes spaces.

# CONFIG_INTERFACE {{{1
#=======================================================================
#
# The configuration interface is a series of menus or dialog boxes that
# allows you to change all the settings that control Bochs's behavior.
# There are two choices of configuration interface: a text mode version
# called "textconfig" and a graphical version called "wx".  The text
# mode version uses stdin/stdout and is always compiled in.  The graphical
# version is only available when you use "--with-wx" on the configure
# command.  If you do not write a config_interface line, Bochs will
# choose a default for you.
#
# NOTE: if you use the "wx" configuration interface, you must also use
# the "wx" display library.
#=======================================================================
config_interface: textconfig
#config_interface: wx


# DISPLAY_LIBRARY {{{1
#=======================================================================
#
# The display library is the code that displays the Bochs VGA screen.  Bochs
# has a selection of about 10 different display library implementations for
# different platforms.  If you run configure with multiple --with-* options,
# the display_library command lets you choose which one you want to run with.
# If you do not write a display_library line, Bochs will choose a default for
# you.
#
# The choices are:
#   x              use X windows interface, cross platform
#   win32          use native win32 libraries
#   carbon         use Carbon library (for MacOS X)
#   beos           use native BeOS libraries
#   macintosh      use MacOS pre-10
#   amigaos        use native AmigaOS libraries
#   sdl            use SDL library, cross platform
#   svga           use SVGALIB library for Linux, allows graphics without X11
#   term           text only, uses curses/ncurses library, cross platform
#   rfb            provides an interface to AT&T's VNC viewer, cross platform
#   wx             use wxWidgets library, cross platform
#   nogui          no display at all
#
# NOTE: if you use the "wx" configuration interface, you must also use
# the "wx" display library.
#
# Specific options:
# Some display libraries now support specific option to control their
# behaviour. See the examples below for currently supported options.
#=======================================================================
#display_library: amigaos
#display_library: beos
#display_library: carbon
#display_library: macintosh
#display_library: nogui
#display_library: rfb, options="timeout=60" # time to wait for client
#display_library: sdl, options="fullscreen" # startup in fullscreen mode
#display_library: term
#display_library: win32, options="legacyF12" # use F12 to toggle mouse
#display_library: win32, options="gui_debug" # use Win32 debugger gui
#display_library: wx
#display_library: x, options="hideIPS" # disable IPS output in status bar
#display_library: x, options="gui_debug" # use GTK debugger gui
display_library: x

# ROMIMAGE: {{{1
#=======================================================================
# The ROM BIOS controls what the PC does when it first powers on.
# Normally, you can use a precompiled BIOS in the source or binary
# distribution called BIOS-bochs-latest. The ROM BIOS is usually loaded
# starting at address 0xf0000, and it is exactly 64k long. Another option
# is 128k BIOS which is loaded at address 0xe0000.
# You can also use the environment variable $BXSHARE to specify the
# location of the BIOS.
# The usage of external large BIOS images (up to 512k) at memory top is
# now supported, but we still recommend to use the BIOS distributed with
# Bochs. The start address optional, since it can be calculated from image size.
#=======================================================================
romimage: $[ROMIMAGE]
#romimage: file=mybios.bin, address=0xfff80000 # 512k at memory top

# CPU: {{{1
#=======================================================================
# This defines cpu-related parameters inside Bochs:
#
#  COUNT:
#  Set the number of processors:cores per processor:threads per core
#  when Bochs is compiled for SMP emulation.
#  Bochs currently supports up to 8 threads running simultaniosly.
#  If Bochs is compiled without SMP support, it won't accept values
#  different from 1.
#
#  QUANTUM:
#  Maximum amount of instructions allowed to execute by processor before
#  returning control to another cpu. This option exists only in Bochs
#  binary compiled with SMP support.
#
#  RESET_ON_TRIPLE_FAULT:
#  Reset the CPU when triple fault occur (highly recommended) rather than
#  PANIC. Remember that if you trying to continue after triple fault the
#  simulation will be completely bogus !
#
#  CPUID_LIMIT_WINNT:
#  Determine whether to limit maximum CPUID function to 3. This mode is
#  required to workaround WinNT installation and boot issues.
#
#  MSRS:
#  Define path to user CPU Model Specific Registers (MSRs) specification.
#  See example in msrs.def.
#
#  VENDOR_STRING:
#  Set the CPUID vendor string returned by CPUID(0x0). This should be a
#  twelve-character ASCII string.
#
#  BRAND_STRING:
#  Set the CPUID vendor string returned by CPUID(0x80000002 .. 0x80000004).
#  This should be at most a forty-eight-character ASCII string.
#
#  IPS:
#  Emulated Instructions Per Second. This is the number of IPS that bochs
#  is capable of running on your machine. You can recompile Bochs with
#  --enable-show-ips option enabled, to find your host's capability.
#  Measured IPS value will then be logged into your log file or shown
#  in the status bar (if supported by the gui).
#
#  IPS is used to calibrate many time-dependent events within the bochs
#  simulation.  For example, changing IPS affects the frequency of VGA
#  updates, the duration of time before a key starts to autorepeat, and
#  the measurement of BogoMips and other benchmarks.
#
#  Examples:
#
#  Bochs Machine/Compiler                                 Mips
# ____________________________________________________________________
#  2.3.7 3.2Ghz Intel Core 2 Q9770 with WinXP/g++ 3.4    50 to 55 Mips
#  2.3.7 2.6Ghz Intel Core 2 Duo with WinXP/g++ 3.4      38 to 43 Mips
#  2.2.6 2.6Ghz Intel Core 2 Duo with WinXP/g++ 3.4      21 to 25 Mips
#  2.2.6 2.1Ghz Athlon XP with Linux 2.6/g++ 3.4         12 to 15 Mips
#  2.0.1 1.6Ghz Intel P4 with Win2000/g++ 3.3             5 to  7 Mips
#=======================================================================
$[CPU] , reset_on_triple_fault=0

# MEGS {{{1
#=======================================================================
# Set the number of Megabytes of physical memory you want to emulate.
# The default is 32MB, most OS's won't need more than that.
# The maximum amount of memory supported is 2048Mb.
#=======================================================================
#megs: 256
#megs: 128
#megs: 64
#megs: 32
#megs: 16
megs: 8

# VGAROMIMAGE {{{1
#=======================================================================
# You now need to load a VGA ROM BIOS into C0000.
#=======================================================================
#vgaromimage: file=bios/VGABIOS-elpin-2.40
vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest
#vgaromimage: file=bios/VGABIOS-lgpl-latest-cirrus

# VGA: {{{1
#=======================================================================
# Here you can specify the display extension to be used. With the value
# 'none' you can use standard VGA with no extension. Other supported
# values are 'vbe' for Bochs VBE and 'cirrus' for Cirrus SVGA support.
#=======================================================================
#vga: extension=cirrus
#vga: extension=vbe

# ATA0, ATA1, ATA2, ATA3 {{{1
#=======================================================================
# ATA controller for hard disks and cdroms
#
# ata[0-3]: enabled=[0|1], ioaddr1=addr, ioaddr2=addr, irq=number
#
# These options enables up to 4 ata channels. For each channel
# the two base io addresses and the irq must be specified.
#
# ata0 and ata1 are enabled by default with the values shown below
#
# Examples:
#   ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
#   ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
#   ata2: enabled=1, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
#   ata3: enabled=1, ioaddr1=0x168, ioaddr2=0x360, irq=9
#=======================================================================
ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
ata2: enabled=0, ioaddr1=0x1e8, ioaddr2=0x3e0, irq=11
ata3: enabled=0, ioaddr1=0x168, ioaddr2=0x360, irq=9

# ATA[0-3]-MASTER, ATA[0-3]-SLAVE {{{1
#=======================================================================
#
# This defines the type and characteristics of all attached ata devices:
#   type=       type of attached device [disk|cdrom]
#   mode=       only valid for disks [flat|concat|external|dll|sparse|vmware3]
#   mode=       only valid for disks [undoable|growing|volatile]
#   path=       path of the image
#   cylinders=  only valid for disks
#   heads=      only valid for disks
#   spt=        only valid for disks
#   status=     only valid for cdroms [inserted|ejected]
#   biosdetect= type of biosdetection [none|auto], only for disks on ata0 [cmos]
#   translation=type of translation of the bios, only for disks [none|lba|large|rechs|auto]
#   model=      string returned by identify device command
#   journal=    optional filename of the redolog for undoable and volatile disks
#
# Point this at a hard disk image file, cdrom iso file, or physical cdrom
# device.  To create a hard disk image, try running bximage.  It will help you
# choose the size and then suggest a line that works with it.
#
# In UNIX it may be possible to use a raw device as a Bochs hard disk,
# but WE DON'T RECOMMEND IT.  In Windows there is no easy way.
#
# In windows, the drive letter + colon notation should be used for cdroms.
# Depending on versions of windows and drivers, you may only be able to
# access the "first" cdrom in the system.  On MacOSX, use path="drive"
# to access the physical drive.
#
# The path is mandatory for hard disks. Disk geometry autodetection works with
# images created by bximage if CHS is set to 0/0/0 (cylinders are calculated
# using  heads=16 and spt=63). For other hard disk images and modes the
# cylinders, heads, and spt are mandatory. In all cases the disk size reported
# from the image must be exactly C*H*S*512.
#
# Default values are:
#   mode=flat, biosdetect=auto, translation=auto, model="Generic 1234"
#
# The biosdetect option has currently no effect on the bios
#
# Examples:
#   ata0-master: type=disk, mode=flat, path=10M.sample, cylinders=306, heads=4, spt=17
#   ata0-slave:  type=disk, mode=flat, path=20M.sample, cylinders=615, heads=4, spt=17
#   ata1-master: type=disk, mode=flat, path=30M.sample, cylinders=615, heads=6, spt=17
#   ata1-slave:  type=disk, mode=flat, path=46M.sample, cylinders=940, heads=6, spt=17
#   ata2-master: type=disk, mode=flat, path=62M.sample, cylinders=940, heads=8, spt=17
#   ata2-slave:  type=disk, mode=flat, path=112M.sample, cylinders=900, heads=15, spt=17
#   ata3-master: type=disk, mode=flat, path=483M.sample, cylinders=1024, heads=15, spt=63
#   ata3-slave:  type=cdrom, path=iso.sample, status=inserted
#=======================================================================
ata0-master: type=disk, path="SWEB-flat.vmdk", mode=flat, cylinders=209,heads=16, spt=63

# BOOT: {{{1
#=======================================================================
# This defines the boot sequence. Now you can specify up to 3 boot drives,
# which can be 'floppy', 'disk', 'cdrom' or 'network' (boot ROM).
# Legacy 'a' and 'c' are also supported.
# Examples:
#   boot: floppy
#   boot: cdrom, disk
#   boot: network, disk
#   boot: cdrom, floppy, disk
#=======================================================================
boot: disk


# LOG: {{{1
#=======================================================================
# Give the path of the log file you'd like Bochs debug and misc. verbiage
# to be written to. If you don't use this option or set the filename to
# '-' the output is written to the console. If you really don't want it,
# make it "/dev/null" (Unix) or "nul" (win32). :^(
#
# Examples:
#   log: ./bochs.out
#   log: /dev/tty
#=======================================================================
#log: /dev/null
log: bochsout.txt

# LOGPREFIX: {{{1
#=======================================================================
# This handles the format of the string prepended to each log line.
# You may use those special tokens :
#   %t : 11 decimal digits timer tick
#   %i : 8 hexadecimal digits of cpu current eip (ignored in SMP configuration)
#   %e : 1 character event type ('i'nfo, 'd'ebug, 'p'anic, 'e'rror)
#   %d : 5 characters string of the device, between brackets
#
# Default : %t%e%d
# Examples:
#   logprefix: %t-%e-@%i-%d
#   logprefix: %i%e%d
#=======================================================================
#logprefix: %t%e%d

# LOG CONTROLS {{{1
#=======================================================================
#
# Bochs now has four severity levels for event logging.
#   panic: cannot proceed.  If you choose to continue after a panic,
#          don't be surprised if you get strange behavior or crashes.
#   error: something went wrong, but it is probably safe to continue the
#          simulation.
#   info: interesting or useful messages.
#   debug: messages useful only when debugging the code.  This may
#          spit out thousands per second.
#
# For events of each level, you can choose to crash, report, or ignore.
# TODO: allow choice based on the facility: e.g. crash on panics from
#       everything except the cdrom, and only report those.
#
# If you are experiencing many panics, it can be helpful to change
# the panic action to report instead of fatal.  However, be aware
# that anything executed after a panic is uncharted territory and can
# cause bochs to become unstable.  The panic is a "graceful exit," so
# if you disable it you may get a spectacular disaster instead.
#=======================================================================
panic: action=ask
error: action=report
info: action=report
debug: action=ignore
#pass: action=fatal

# DEBUGGER_LOG: {{{1
#=======================================================================
# Give the path of the log file you'd like Bochs to log debugger output.
# If you really don't want it, make it /dev/null or '-'. :^(
#
# Examples:
#   debugger_log: ./debugger.out
#=======================================================================
#debugger_log: /dev/null
#debugger_log: debugger.out
debugger_log: -

# VGA_UPDATE_INTERVAL: {{{1
#=======================================================================
# Video memory is scanned for updates and screen updated every so many
# virtual seconds.  The default is 50000, about 20Hz. Keep in mind that
# you must tweak the 'cpu: ips=N' directive to be as close to the number
# of emulated instructions-per-second your workstation can do, for this
# to be accurate.
#
# Examples:
#   vga_update_interval: 250000
#=======================================================================
vga_update_interval: 300000

# using for Winstone '98 tests
#vga_update_interval:  100000

# KEYBOARD_SERIAL_DELAY: {{{1
#=======================================================================
# Approximate time in microseconds that it takes one character to
# be transfered from the keyboard to controller over the serial path.
# Examples:
#   keyboard_serial_delay: 200
#=======================================================================
keyboard_serial_delay: 250

# KEYBOARD_PASTE_DELAY: {{{1
#=======================================================================
# Approximate time in microseconds between attempts to paste
# characters to the keyboard controller. This leaves time for the
# guest os to deal with the flow of characters.  The ideal setting
# depends on how your operating system processes characters.  The
# default of 100000 usec (.1 seconds) was chosen because it works
# consistently in Windows.
#
# If your OS is losing characters during a paste, increase the paste
# delay until it stops losing characters.
#
# Examples:
#   keyboard_paste_delay: 100000
#=======================================================================
keyboard_paste_delay: 100000

# MOUSE: {{{1
#=======================================================================
# The Bochs gui creates mouse "events" unless the 'enabled' option is
# set to 0. The hardware emulation itself is not disabled by this.
# Unless you have a particular reason for enabling the mouse by default,
# it is recommended that you leave it off. You can also toggle the mouse
# usage at runtime (control key + middle mouse button on X11, SDL,
# wxWidgets and Win32).
# With the mouse type option you can select the type of mouse to emulate.
# The default value is 'ps2'. The other choices are 'imps2' (wheel mouse
# on PS/2), 'serial', 'serial_wheel' and 'serial_msys' (one com port requires
# setting 'mode=mouse'). To connect a mouse to an USB port, see the 'usb_uhci'
# or 'usb_ohci' option (requires PCI and USB support).
#
# Examples:
#   mouse: enabled=1
#   mouse: enabled=1, type=imps2
#   mouse: enabled=1, type=serial
#   mouse: enabled=0
#=======================================================================
mouse: enabled=0

# private_colormap: Request that the GUI create and use it's own {{{1
#=======================================================================
#                   non-shared colormap.  This colormap will be used
#                   when in the bochs window.  If not enabled, a
#                   shared colormap scheme may be used.  Not implemented
#                   on all GUI's.
#
# Examples:
#   private_colormap: enabled=1
#   private_colormap: enabled=0
#=======================================================================
private_colormap: enabled=0

# KEYBOARD_MAPPING: {{{1
#=======================================================================
# This enables a remap of a physical localized keyboard to a
# virtualized us keyboard, as the PC architecture expects.
# If enabled, the keymap file must be specified.
#
# Examples:
#   keyboard_mapping: enabled=1, map=gui/keymaps/x11-pc-de.map
#=======================================================================
keyboard_mapping: enabled=0, map=

# KEYBOARD_TYPE: {{{1
#=======================================================================
# Type of keyboard return by a "identify keyboard" command to the
# keyboard controler. It must be one of "xt", "at" or "mf".
# Defaults to "mf". It should be ok for almost everybody. A known
# exception is french macs, that do have a "at"-like keyboard.
#
# Examples:
#   keyboard_type: mf
#=======================================================================
#keyboard_type: mf

# USER_SHORTCUT: {{{1
#=======================================================================
# This defines the keyboard shortcut to be sent when you press the "user"
# button in the headerbar. The shortcut string is a combination of maximum
# 3 key names (listed below) separated with a '-' character.
# Valid key names:
# "alt", "bksl", "bksp", "ctrl", "del", "down", "end", "enter", "esc",
# "f1", ... "f12", "home", "ins", "left", "menu", "minus", "pgdwn", "pgup",
# "plus", "right", "shift", "space", "tab", "up", "win", "print" and "power".
#
# Example:
#   user_shortcut: keys=ctrl-alt-del
#=======================================================================
#user_shortcut: keys=ctrl-alt-del

# I440FXSUPPORT: {{{1
#=======================================================================
# This option controls the presence of the i440FX PCI chipset. You can
# also specify the devices connected to PCI slots. Up to 5 slots are
# available now. These devices are currently supported: ne2k, pcivga,
# pcidev, pcipnic and usb_ohci. If Bochs is compiled with Cirrus SVGA
# support you'll have the additional choice 'cirrus'.
#
# Example:
#   i440fxsupport: enabled=1, slot1=pcivga, slot2=ne2k
#=======================================================================
#i440fxsupport: enabled=1

# MAGIC_BREAK: {{{1
#=======================================================================
# This enables the "magic breakpoint" feature when using the debugger.
# The useless cpu instruction XCHG BX, BX causes Bochs to enter the
# debugger mode. This might be useful for software development.
#
# Example:
#   magic_break: enabled=1
#=======================================================================
#magic_break: enabled=1

# PORT_E9_HACK: {{{1
#=======================================================================
# The 0xE9 port doesn't exists in normal ISA architecture. However, we
# define a convention here, to display on the console of the system running
# Bochs anything that is written to it. The idea is to provide debug output
# very early when writing BIOS or OS code for example, without having to
# bother with setting up a serial port or etc. Reading from port 0xE9 will
# will return 0xe9 to let you know if the feature is available.
# Leave this 0 unless you have a reason to use it.
#
# Example:
#   port_e9_hack: enabled=1
#=======================================================================
#port_e9_hack: enabled=1

# DEBUG_SYMBOLS: {{{1
#=======================================================================
# This loads symbols from the specified file for use in Bochs' internal
# debugger. Symbols are loaded into global context. This is equivalent to
# issuing ldsym debugger command at start up.
#
# Example:
#   debug_symbols: file="kernel.sym"
#   debug_symbols: file="kernel.sym", offset=0x80000000
#=======================================================================
#debug_symbols: file="kernel.sym"

# other stuff {{{1
#=======================================================================
#=======================================================================
#load32bitOSImage: os=nullkernel, path=../kernel.img, iolog=../vga_io.log
#load32bitOSImage: os=linux, path=../linux.img, iolog=../vga_io.log, initrd=../initrd.img
#text_snapshot_check: enabled=1
#print_timestamps: enabled=1

#-------------------------
# PCI host device mapping
#-------------------------
#pcidev: vendor=0x1234, device=0x5678

# GDBSTUB: {{{1
#=======================================================================
# Enable GDB stub. See user documentation for details.
# Default value is enabled=0.
#=======================================================================
#gdbstub: enabled=0, port=1234, text_base=0, data_base=0, bss_base=0

# PLUGIN_CTRL: {{{1
#=======================================================================
# Controls the presence of optional plugins without a separate option.
# By default all existing plugins are enabled. These plugins are currently
# supported: 'acpi', 'biosdev', 'extfpuirq', 'gameport', 'iodebug',
# 'pci_ide', 'speaker' and 'unmapped'.
#=======================================================================
#plugin_ctrl: biosdev=0, speaker=0

# USER_PLUGIN: {{{1
#=======================================================================
# Load user-defined plugin. This option is available only if Bochs is
# compiled with plugin support. Maximum 8 different plugins are supported.
# See the example in the Bochs sources how to write a plugin device.
#=======================================================================
#user_plugin: name=testdev

# for Macintosh, use the style of pathnames in the following {{{1
#=======================================================================
# examples.
#
# vgaromimage: :bios:VGABIOS-elpin-2.40
# romimage: file=:bios:BIOS-bochs-latest, address=0xf0000
# floppya: 1_44=[fd:], status=inserted
#=======================================================================
